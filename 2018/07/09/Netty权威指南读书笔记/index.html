<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="xinshiyou">
  <meta name="keywords" content="">
  <title>Netty权威指南读书笔记 - 星空捞月：找寻心中的安宁</title>

  


  
  

  
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->










<!-- 自定义样式保持在最底部 -->


  
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="星空捞月：找寻心中的安宁" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css');loadCss('https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css');loadCss('https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css');loadCss('//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css');loadCss('//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css');loadCss('https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"></noscript></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>星空捞月：找寻心中的安宁</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax="true" style="background: url('/img/top.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2018-07-09 19:38">
      2018年7月9日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      93
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>  Netty权威指南，是一本广受欢迎的Netty书籍。博主研读的是2014年6月第一版，第二次印刷的书本。</p>
<a id="more"></a>
<h1 id="基础篇-走进Java-NIO"><a href="#基础篇-走进Java-NIO" class="headerlink" title="基础篇  走进Java NIO"></a>基础篇  走进Java NIO</h1><h2 id="Java的I-O演进之路"><a href="#Java的I-O演进之路" class="headerlink" title="Java的I/O演进之路"></a>Java的I/O演进之路</h2><h3 id="I-O入门"><a href="#I-O入门" class="headerlink" title="I/O入门"></a>I/O入门</h3><p>  Java1.4之前，Java的I/O还不完善，开发人员在开发该性能I/O时，会遇到困难：</p>
<ul>
<li>没有缓冲区，I/O性能存在问题</li>
<li>没有Channe概念，只有输入/输出流</li>
<li>同步阻塞I/O(BIO)通讯，导致通讯线程长时间阻塞</li>
<li>支持字符集有限，硬件可移植性不好</li>
</ul>
<p>  高性能开发领域，很长一段时间里一直被C++/C长期占据，Java的BIO被大家所诟病。</p>
<h4 id="Linux网络I-O模型"><a href="#Linux网络I-O模型" class="headerlink" title="Linux网络I/O模型"></a>Linux网络I/O模型</h4><ol>
<li>阻塞I/O模型</li>
<li>费阻塞I/O模型</li>
<li>I/O复用模型</li>
<li>信号驱动I/O模型</li>
<li>异步I/O模型</li>
</ol>
<h4 id="I-O多路复用技术"><a href="#I-O多路复用技术" class="headerlink" title="I/O多路复用技术"></a>I/O多路复用技术</h4><p>  I/O多路复用的应用场景</p>
<ul>
<li>服务器需要同时处理多个监听状态或连接状态的套接字</li>
<li>服务器需要同时处理多种网络协议的套接字</li>
</ul>
<p>  Linux网络I/O模型总结：select—&gt;epoll</p>
<ol>
<li>支持一个进程打开的socket描述符不受限制(仅受限于系统的最大文件句柄数)</li>
<li>I/O效率不会随着FD数目的增加而线性下降</li>
<li>使用mmap加速内核与用户空间的消息传递</li>
<li>epoll的API更加简单</li>
</ol>
<h3 id="Java的I-O演进"><a href="#Java的I-O演进" class="headerlink" title="Java的I/O演进"></a>Java的I/O演进</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="NIO入门"><a href="#NIO入门" class="headerlink" title="NIO入门"></a>NIO入门</h2><p>  主要讲解BIO、NIO、NIO2.0的使用。主要包括</p>
<ol>
<li>传统的BIO模型</li>
<li>基于NIO的费阻塞编程</li>
<li>基于NIO2.0的异步费阻塞(AIO)编程</li>
<li>为什么需要使用NIO</li>
<li>为什么选择Netty</li>
</ol>
<h3 id="传统BIO编程"><a href="#传统BIO编程" class="headerlink" title="传统BIO编程"></a>传统BIO编程</h3><p>  使用传统的BIO模型，最大的问题是缺乏伸缩能力，当客户端并发数增加后，服务端的线程个数和客户端的并发访问数呈1：1的正比关系。有线程是JVM非常宝贵的资源，当线程数膨胀之后，系统的性能将急剧下降。</p>
<h3 id="伪异步IO编程"><a href="#伪异步IO编程" class="headerlink" title="伪异步IO编程"></a>伪异步IO编程</h3><p>  针对BIO模型的一个优化方案是做线程池。通过线程池控制线程数量，并能够灵活的调整并发线程的数量，防止海量并发接入导致线程耗尽。</p>
<p>  伪异步IO编程实际上是对BIO的一个简单优化，但它并没有从本质上回避BIO的缺点，可能会造成如下后果</p>
<ol>
<li>相应缓慢</li>
<li>线程池技术，前面进入线程池的任务可能会影响后面任务的运行</li>
<li>线程池满了之后，后续加入任务会被阻塞</li>
</ol>
<h3 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h3><p>  NIO概念的理解。一种是New IO，这也是官方的叫法。另外一种是Non-Block IO，即非阻塞IO。</p>
<h4 id="NIO类库"><a href="#NIO类库" class="headerlink" title="NIO类库"></a>NIO类库</h4><ol>
<li>缓冲区Buffer</li>
</ol>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<ol>
<li>通道Channel<ul>
<li>网络读写SelectableChannel</li>
<li>文件操作的FileChannel</li>
</ul>
</li>
<li>多路复用器Selector</li>
</ol>
<h3 id="AIO编程"><a href="#AIO编程" class="headerlink" title="AIO编程"></a>AIO编程</h3><p>  NIO2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步通道通过两种方式获取操作结果</p>
<ol>
<li>java.util.concurrent.Future</li>
<li>在执行异步操作的时候，传入一个java.nio.channel</li>
</ol>
<p>  <em>不同模型的比较</em><br>||异步阻塞IO(BIO)|伪异步IO|非阻塞IO(NIO)|异步IO(AIO)|<br>|:-:|:-:|:-:|:-:|:-:|<br>客户端个数：IO线程数|1:1|M:N(M&gt;N)|M:1(1个IO线程处理多个客户端进程)|M:0(不需要启动额外的线程，被动回调)|<br>IO类型(阻塞)|阻塞IO|阻塞IO|阻塞IO|非阻塞IO|非阻塞IO|<br>IO类型(同步)|同步IO|同步IO|同步IO(多路复用)|异步IO|<br>API使用难度|简单|简单|非常复杂|复杂|<br>调试难度|简单|简答|复杂|复杂|<br>可靠性|非常差|差|高|高|<br>吞吐量|低|中|高|高|</p>
<h3 id="选择Netty的理由"><a href="#选择Netty的理由" class="headerlink" title="选择Netty的理由"></a>选择Netty的理由</h3><ol>
<li>为什么不选择原生Java NIO</li>
</ol>
<ul>
<li>NIO的类库和API使用复杂</li>
<li>具备额外技能作铺垫</li>
<li>可靠性能差，工作难度较大</li>
<li>JDK NIO存在BUG</li>
</ul>
<ol>
<li>为什么选择Netty</li>
</ol>
<ul>
<li>API使用简单，开发门槛较低</li>
<li>功能强大，预支了多种解码器，支持多种主流协议</li>
<li>定制能力强</li>
<li>性能高</li>
<li>成熟、稳定</li>
<li>社区活跃，班底迭代周期短，发现的BUG被及时修复</li>
</ul>
<h1 id="入门篇-Netty-NIO开发指南"><a href="#入门篇-Netty-NIO开发指南" class="headerlink" title="入门篇 Netty NIO开发指南"></a>入门篇 Netty NIO开发指南</h1><h2 id="Netty入门应用"><a href="#Netty入门应用" class="headerlink" title="Netty入门应用"></a>Netty入门应用</h2><p>  使用Netty实现TimeServer服务器端与客户端通讯服务<br></p><pre class=" language-hljs java"><code class="language-hljs java">## 服务器端代码
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerServer</span></span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception</span>{
        <span class="hljs-comment">// 配置服务端的NIO线程组</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span>{
            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();
            b.group(bossGroup,workGroup)
            .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">            .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BACKLOG</span>,1024)</span>
<span class="hljs-class">            .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChildChannelHandler</span>())</span>;

            <span class="hljs-comment">// 绑定端口，同步等待成功</span>
            ChannelFuture f = b.bind(port).sync();

            <span class="hljs-comment">// 等待服务端口监听端口关闭</span>
            f.channel().closeFuture().sync();
        }<span class="hljs-keyword">finally</span>{
            <span class="hljs-comment">// 优雅退出，释放线层组资源</span>
            bossGroup.shutdownGracefully();
            workGroup.shutdownGracefully();
        }
        
    }

    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;</span>{

        <span class="hljs-meta">@override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">iniitChannel</span><span class="hljs-params">(SocketChannel args0)</span> <span class="hljs-keyword">throws</span> Exception </span>{
            args0.pipeline()/addLast(<span class="hljs-keyword">new</span> TimeServerHandler());
        }

    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@desc</span> 测试时间服务器</span>
<span class="hljs-comment">    */</span> 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>;
        <span class="hljs-keyword">if</span>(args!=<span class="hljs-keyword">null</span> &amp;&amp; args.length&gt;<span class="hljs-number">0</span>){
            <span class="hljs-keyword">try</span>{
                port = Integer.valueOf(args[<span class="hljs-number">0</span>]);
            }<span class="hljs-keyword">catch</span>(NumberFormatException e){
                <span class="hljs-comment">// 采用默认值</span>
            }
        }

        <span class="hljs-keyword">new</span> TimeServer().bind(port);

    }

}

<span class="hljs-comment">/** Netty时间服务器服务端TimeServerHandler */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandlerAdapter</span></span>{

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx,Object msg)</span> <span class="hljs-keyword">throws</span> Exception</span>{
    
        Bytebuf buf = (ByteBuf)msg;
        <span class="hljs-keyword">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.readableBytes()];
        buf.readBytes(req);

        String body = <span class="hljs-keyword">new</span> String(req,<span class="hljs-string">"UTF-8"</span>);
        System.out.println(<span class="hljs-string">"The time server receive order : "</span>+body);

        String currentTime = <span class="hljs-string">"QUERY TIME ORDER"</span>.equalsIngnoreCase(body)?<span class="hljs-keyword">new</span> java.util.Date(System.currentTimeMilles()).toString():<span class="hljs-string">"BAD ORDER"</span>;
        
        Bytebuf resp = Unpooled.copiedBuffer(currentTime.getBytes());
        ctx.write(resp);

    }

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>{
        ctx.flush();
    }

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,Throwable cause)</span></span>{
        ctx.close();
    }

}

## 客户端代码
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeClient</span></span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port,String host)</span> <span class="hljs-keyword">throws</span> Exception</span>{

        <span class="hljs-comment">// 配置客户端NIO线程组</span>
        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        <span class="hljs-keyword">try</span>{
            Bootstrap b = <span class="hljs-keyword">new</span> Bootstrap();
            g.group(group)
            .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">            .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">TCP_NODELAY</span>,<span class="hljs-title">trye</span>)</span>
<span class="hljs-class">            .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketHandler</span>&gt;()</span>{
                <span class="hljs-meta">@override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception</span>{
                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> TimeClientChannel());
                }
            });

             <span class="hljs-comment">// 发起异步连接操作</span>
            ChannelFuture f = b.connect(host,port).sync();

            <span class="hljs-comment">// 等待客户端链路关闭</span>
            f.channel().closeFuture().sync();

        }<span class="hljs-keyword">finally</span>{
            group.shutdownGracefully();
        }

    }

    <span class="hljs-comment">/** 主要测试方法 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Stirng[] args)</span></span>{
        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>;
        <span class="hljs-comment">// read port from input parameters if possible</span>
        <span class="hljs-keyword">new</span> TimeClient().bind(port,hostname[ or <span class="hljs-string">"localhost"</span>]);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandlerAdapter</span></span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf firstMessage;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimeClientHandler</span><span class="hljs-params">()</span></span>{

        <span class="hljs-keyword">byte</span>[] req = <span class="hljs-string">"QUERY TIME ORDER"</span>.getBytes();
        firstMessage =Unpooled.buffer(req.length);
        firstMessage.writeBytes(req);
    }

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannleHandlerContext ctx)</span> </span>{
        ctx.writeAndFlush(firstMessage);
    }

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx,Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{

        ByteBuf buf = (ByteBuf)msg;
        <span class="hljs-keyword">byte</span>[] req = <span class="hljs-keyword">new</span> String(buf.readableBytes());
        buf.readBytes(req);
        String body = <span class="hljs-keyword">new</span> String(req,<span class="hljs-string">"UTF-8"</span>);
        System.out.println(<span class="hljs-string">"Now is : "</span>+body);

    }

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,Throwable cause)</span></span>{
        <span class="hljs-comment">// 释放资源</span>
        ctx.close();
    }
}</code></pre><p></p>
<h2 id="TCP黏包-拆包的解决之道"><a href="#TCP黏包-拆包的解决之道" class="headerlink" title="TCP黏包/拆包的解决之道"></a>TCP黏包/拆包的解决之道</h2><p>  使用TCP协议，在发送或传输过程中都需要考虑黏包、拆包问题。</p>
<h3 id="TCP黏包-拆包"><a href="#TCP黏包-拆包" class="headerlink" title="TCP黏包/拆包"></a>TCP黏包/拆包</h3><p>  TCP是一个流协议，是一串没有边界的字符流。TCP底层并不了解上层数据业务数据的含义，他会根据TCP缓冲区的实践情况进行划分，所以在业务上完整的一个包可能会被拆分成多个包进行发送，也有可能多个小包封装成一个大包进行发送，这就是所谓的黏包、拆包问题。</p>
<p>  问题产生的原因：</p>
<ol>
<li>应用程序write的字节大小大于套接字缓冲区大小</li>
<li>进行MSS大小的TCP分段</li>
<li>以太网帧的payload大于MTU进行IP分片</li>
</ol>
<p>  解决策略</p>
<ol>
<li>消息定长，如果不够空位补齐</li>
<li>在包尾部增加会回车换行符，例如FTP协议</li>
<li>将消息分为消息头和消息体，消息头中包含消息的总长度</li>
<li>更复杂的应用层协议</li>
</ol>
<h3 id="Netty解决读半包问题"><a href="#Netty解决读半包问题" class="headerlink" title="Netty解决读半包问题"></a>Netty解决读半包问题</h3><p>  为了解决TCP黏包、拆包问题，Netty引入了多种编码解码器用于处理半包问题，只要能够熟悉掌握这些类库，解决黏包问题非常容易。</p>
<p>  LineBasedFrameDecoder的原理是依次遍历ByteBuf中的可读字节，判断是否存在换行符”\n”、”\r\n”。如果有，就以此为结束位置，从可读索引到结束位置的字节就组成了一行。</p>
<p>  StringDecorder的功能非常简单，就是将发送的对象转换成字符串，然后继续条用Handler。LineBasedFrameDecoder+StringDecoder组合就是按照行切分的文本解码器，它用来支持解决TCP的黏包和拆包。</p>
<h2 id="分隔符和定长符解码器的应用"><a href="#分隔符和定长符解码器的应用" class="headerlink" title="分隔符和定长符解码器的应用"></a>分隔符和定长符解码器的应用</h2><p>  TCP以流的方式进程数据传输，上层的应用协议对消息进行了区分，往往采用如下方式</p>
<ol>
<li>消息长度固定</li>
<li>将回车作为换行符</li>
<li>将特殊的分隔符作为消息的结束位置</li>
<li>通过在消息头中定义长度字段来标识消息的长度</li>
</ol>
<h3 id="DelimiterBasedFrameDecoder应用开发"><a href="#DelimiterBasedFrameDecoder应用开发" class="headerlink" title="DelimiterBasedFrameDecoder应用开发"></a>DelimiterBasedFrameDecoder应用开发</h3><p>  DelimiterBasedFrameDecoder可以根据自定义分隔符作为结束位置，在使用的时候传入两个参数<br></p><pre class=" language-hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">DelimiterBasedFrameDecoder(1024,Bytebuf:: <span class="hljs-params"><code class="language-hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">DelimiterBasedFrameDecoder(1024,Bytebuf:: <span class="hljs-params">delimiter</span>)</span></code></span></span></pre><br>其中第一个参数表示消息的最大长度，第二参数表示分隔符。<p></p>
<h3 id="FixedLengthFrameDecoder应用开发"><a href="#FixedLengthFrameDecoder应用开发" class="headerlink" title="FixedLengthFrameDecoder应用开发"></a>FixedLengthFrameDecoder应用开发</h3><p>  FixedLengthFrameDecoder是固定长度解码器，它能够按照固定的长度对消息进行自动解码，开发者不需要考虑TCP的黏包和拆包问题。<br></p><pre class=" language-hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type">FixedLengthFrameDecoder</span>(<span class="hljs-number"><code class="language-hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type">FixedLengthFrameDecoder</span>(<span class="hljs-number">10</span>)</code></span></pre><br>其中10表示固定长度。<p></p>
<h1 id="中级篇-Netty编解码开发指南"><a href="#中级篇-Netty编解码开发指南" class="headerlink" title="中级篇 Netty编解码开发指南"></a>中级篇 Netty编解码开发指南</h1><p>  了解Netty内置的编码器之后，继续学习Netty的编码解码款框架的应用，例如java序列化、二进制编码、Google Protobuf和JBoss的Marshallling序列化框架。</p>
<h2 id="编解码技术"><a href="#编解码技术" class="headerlink" title="编解码技术"></a>编解码技术</h2><p>  基于Java提供的对象输入/输出流ObjectInputStreaming和ObjectOutputStreaming，可以直接把Java对象作为可存储的字节流写入文件，也可以传输到网上。对程序员而言，序列化可提高开发效率。</p>
<p>  Java序列化的目的</p>
<ol>
<li>网络传输</li>
<li>对象持久化</li>
</ol>
<h3 id="Java序列化缺点"><a href="#Java序列化缺点" class="headerlink" title="Java序列化缺点"></a>Java序列化缺点</h3><ol>
<li>无法跨语言</li>
<li>序列化后的码流太大</li>
<li>序列化性能太低</li>
</ol>
<h3 id="业界主流的编解码框架"><a href="#业界主流的编解码框架" class="headerlink" title="业界主流的编解码框架"></a>业界主流的编解码框架</h3><ol>
<li>Google Protobuf<br> 主要特点<ul>
<li>结构化存储</li>
<li>搞笑的编解码性能</li>
<li>语言无关、平台无关、扩展性好</li>
<li>官方支持Java、C++和Python三种语言<br>为什么不适用XML走位通讯协议？一方面，解析的时间开销；另一方便，XML为了可读性牺牲的空间开销都非常大。<br>protobuf引入了数据描述文件和代码生成机制，主要优点</li>
<li>文件化的数据结构描述语言，可以实现语言和平台无关，特别适合系统间集成</li>
<li>通过标识字段的顺序，实现协议的兼容</li>
<li>代码生成机制，不需要手动编写同样数据结构的C++和Java版本</li>
<li>方便后续的管理和维护</li>
</ul>
</li>
<li><p>Facebook Thrift<br> thrift主要有一下部分组成</p>
<ul>
<li>语言系统以及IDL编译器：负责由用户给定的IDL文件生成相应语言的接口代码</li>
<li>TProtocal: RPC的协议层，可以选择多个不同的对象序列化方式，如JSON何Binary</li>
<li>TTransport: RPC的传输层，同样可以选择不同的传输层实现，如socket、NIO、MemeroyBuffer等</li>
<li>TProcessor:作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口</li>
<li>TServer: 聚合TProtocal、TTransport和TProcessor等对象<br>Thrift支持三种不同的编解码</li>
<li>通用的二进制编码</li>
<li>压缩二进制编解码</li>
<li>优化的可选字段压缩编解码</li>
</ul>
</li>
<li><p>JBoss Marshalling<br> JBoss Marshalling是一个序列化的API，修正了JDK自带的序列化包的很多问题。相比于前面两种编解码协议，JBoss Marshalling更多是应用于JBoss内部，应用范围有限。</p>
<h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2></li>
</ol>
<p>  Java序列化在Netty NIO框架中的使用方式<br></p><pre class=" language-hljs java"><code class="language-hljs java">## 服务器端：ChannleInitializer<socketchannel>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span></span>{
    ch.pipeline()
        .addLast(<span class="hljs-keyword">new</span> ObjectDecoder(<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>,Classresolvers.weakCachingConcurrentResolver(<span class="hljs-keyword">this</span>.getClass().getClassLoader())));
    ch.pipeline().addLast(<span class="hljs-keyword">new</span> OjectEncoder());
    <span class="hljs-comment">// add other handler</span>
}</socketchannel></code></pre><p></p>
<h2 id="Google-Protobuf编解码"><a href="#Google-Protobuf编解码" class="headerlink" title="Google Protobuf编解码"></a>Google Protobuf编解码</h2><p>  Profotbuf是一个灵活的、小巧的、高效的、结构化的数据序列化框架，相比于XML等传统的序列化工具，它更小、更快、更简单。Profobuf支持一次可以到处使用，甚至跨语言使用，通过代码生成工具可以自动生成不同语言版本的源代码，甚至可以在不同版本的数据结构进程间进行数据传递实现数据结构的前后兼容。</p>
<h3 id="Protobuf开发环境搭建"><a href="#Protobuf开发环境搭建" class="headerlink" title="Protobuf开发环境搭建"></a>Protobuf开发环境搭建</h3><h3 id="Netty的Protobuf服务端开发"><a href="#Netty的Protobuf服务端开发" class="headerlink" title="Netty的Protobuf服务端开发"></a>Netty的Protobuf服务端开发</h3><p>  各种不同版本的示例程序代码，不同点在于ChannelHandlerAdapter的实现方式。其中本部分基于Protobuf的Netty实现方式如下所示<br></p><pre class=" language-hljs java"><code class="language-hljs java">## 服务器端
<span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelHandlerAdapter</span></span>{

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx,Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{

        <span class="hljs-comment">// protobuf object</span>
        Test.TestReq req = (Test.TestReq )msg;<span class="hljs-comment">// 直接强制转化为目标类</span>
        <span class="hljs-comment">// 其他处理</span>
        ctx.writeAndFlush([Target Content]);

    }
}

## 客户端代码类似</code></pre><p></p>
<p>  这里使用到的ProtofReq对象，是通过Protobuf自动化生成的类。</p>
<h2 id="JBoss-Marshelling编解码"><a href="#JBoss-Marshelling编解码" class="headerlink" title="JBoss Marshelling编解码"></a>JBoss Marshelling编解码</h2><p>  JBose Marshalling的序列化编解码框架，应用领域有限不做赘述。</p>
<h1 id="高级篇-Netty多协议开发和应用"><a href="#高级篇-Netty多协议开发和应用" class="headerlink" title="高级篇 Netty多协议开发和应用"></a>高级篇 Netty多协议开发和应用</h1><h2 id="Http协议开发应用"><a href="#Http协议开发应用" class="headerlink" title="Http协议开发应用"></a>Http协议开发应用</h2><p>  Http协议是建立在TCP传输层协议之上的应用层协议，是一个属于应用层的面向对象的协议。与1990年提出，经过多年的发展逐渐完善。Netty的Http协议栈是基于Netty的NIO通讯框架，因此Netty的Http协议也是异步非阻塞的。</p>
<h3 id="Http协议介绍"><a href="#Http协议介绍" class="headerlink" title="Http协议介绍"></a>Http协议介绍</h3><p>  Http协议主要有一下特点</p>
<ul>
<li>支持Client/Server模式</li>
<li>简单：客户端发送请求时，只需要制定服务URL，携带必要的请求参数或消息体即可</li>
<li>灵活-Http允许传输任意类型的数据，传输类型在Http消息头中的Content-Type加以标记</li>
<li>无状态-Http协议是无状态协议，既对于事物处理没有记忆能力。</li>
</ul>
<h4 id="Http请求消息"><a href="#Http请求消息" class="headerlink" title="Http请求消息"></a>Http请求消息</h4><ol>
<li>消息组成<ul>
<li>Http请求行</li>
<li>Http消息头</li>
<li>Http请求正文</li>
</ul>
</li>
<li>请求方法<ul>
<li>GET：请求资源</li>
<li>POST: 请求资源并附加提交数据</li>
<li>HEAD: 请求消息报头</li>
<li>PUT: 请求存储一个资源</li>
<li>DELETE: 请求服务器删除一个资源</li>
<li>TRACE: 请求服务器会送收到的请求消息，主要用于测试或诊断</li>
<li>Connect: 保留将来使用</li>
<li>Options: 请求查询服务器的性能</li>
</ul>
</li>
</ol>
<h4 id="Http相应消息"><a href="#Http相应消息" class="headerlink" title="Http相应消息"></a>Http相应消息</h4><ol>
<li>效应状态<ul>
<li>1XX: 指示消息。请求已接收，继续处理</li>
<li>2XX: 成功。请求已被成功接收、理解、接收</li>
<li>3XX：重定向。要完成请求必须进行更进一步的操作</li>
<li>4XX: 客户端错误。请求有语法错误或请无法实现</li>
<li>5XX: 服务端错误。服务器未能处理请求</li>
</ul>
</li>
<li>常见相应代码与描述<br> |状态码|<center>状态描述</center>|<br> |:-:|:-|<br> |200|OK:客户端请求成功|<br> |400|Bad Request: 客户端请求存在语法错误，不能被服务器所理解|<br> |401|Unauthorized: 请未经授，这个状态代码必须和WWW-Authenticate报头域一起使用|<br> |403|Forbidden:服务器收到请求，但拒绝提供服务|<br> |404|Not Found: 请求资源不存在|<br> |500|Internal Server Error: 服务器发生不可预期的错误|<br> |503|Server Unavailabkle: 服务器当前不能处理客户端的请求，一段时间之后可能恢复|</li>
</ol>
<h3 id="Http协议的Netty处理"><a href="#Http协议的Netty处理" class="headerlink" title="Http协议的Netty处理"></a>Http协议的Netty处理</h3><p>  服务器端重点代码<br></p><pre class=" language-hljs java"><span class="hljs-meta">@override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception</span>{
    ch.pipleline().addLast(<span class="hljs-string">"http-decoder"</span>,<span class="hljs-keyword">new</span> HttpRequestDecoder());
    ch.pipleline().addLast(<span class="hljs-string">"http-aggregator"</span>,<span class="hljs-keyword">new</span> HttpObjectAgregator(<span class="hljs-number">65536</span>));
    ch.pipleline().addLast(<span class="hljs-string">"http-encoder"</span>,<span class="hljs-keyword">new</span> HttpResponseEncoder());
    ch.pipleline().addLast(<span class="hljs-string">"http-chunked"</span>,<span class="hljs-keyword">new</span> ChunkedWriteHandler());

    <span class="hljs-comment">// 自定义: extends SimpleChannelInboundsHandler<fullhttprequest></fullhttprequest></span>
    ch.pipleline().addLast(<span class="hljs-string">"fileServerHandler"</span>,<span class="hljs-keyword">new</span> HttpFileServerHandler(url);
}</code></span></span></pre><p></p>
<h3 id="Netty-Http-XML协议栈开发"><a href="#Netty-Http-XML协议栈开发" class="headerlink" title="Netty Http+XML协议栈开发"></a>Netty Http+XML协议栈开发</h3><p>  由于Http协议的通用性，异构系统间的通讯交互采用Http协议，通过Http协议承载业务数据进行消息交互。例如流行的Http+XML，或RestFUL+JSON。</p>
<p>  在java领域，最常用的Http协议栈就是基于Serverlet规范的Tomcat等Web容器。由于Google等大佬的强力推荐，Jetty等轻量级Web容器也得到了广泛的应用。但许多场景下，基于Http的应用都是后台应用，Http仅仅是承载数据交换的一个通道，是一个载体而不是Web容器。这种场景下，一般不需要Tomcat这种重量型的Web容器。</p>
<p>  另外网络安全日益严峻的今天，重量级的Web容器由于功能繁琐，会存在很多安全漏洞，典型的如Tomcat。这意味着需要为Wb容器做很多安全加固工作去修补这些漏洞，然而开发中并没有用到这些功能，这就带来了并发和维护成本。在这种场景下，选择一个更加轻量级的http协议栈是个更好的选择。</p>
<p><img src="001.png" srcset="/img/loading.gif" alt="Http+XML协议栈开发"></p>
<p>Netty Http+XML重点代码<br></p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{

    ch.pipleline().addLast(<span class="hljs-string">"http-decoder"</span>,<span class="hljs-keyword">new</span> HttpResponseDecoder());
    ch.pipleline().addLast(<span class="hljs-string">"http-aggregator"</span>,<span class="hljs-keyword">new</span> HttpObjectAgregator(<span class="hljs-number">65536</span>));
    ch.pipleline().addLast(<span class="hljs-string">"xml-decoder"</span>,<span class="hljs-keyword">new</span> HttpXMLResponseDecoder(Order<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">true</span>))</span>;
    ch.pipleline().addLast(<span class="hljs-string">"http-encoder"</span>,<span class="hljs-keyword">new</span> HttpRequestEncoder());
    ch.pipleline().addLast(<span class="hljs-string">"xml-encoder"</span>,<span class="hljs-keyword">new</span> HttpXMLRequestEncoder());

    ch.pipleline().addLast(<span class="hljs-string">"fileServerHandler"</span>,<span class="hljs-keyword">new</span> HttpXMLHandler());
}</code></span></pre><p></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  尽管本文中开发的Http+XML协议栈是一个高性能、通用的协议栈，但这里忽略了异常处理、可扩展性的API和配置能力。所以如果想要做产品化的协议栈，还需要一些额外的完善。</p>
<h2 id="WebSocket协议开发"><a href="#WebSocket协议开发" class="headerlink" title="WebSocket协议开发"></a>WebSocket协议开发</h2><p>  一直以来，网络在很多程度上都是围绕着Http的请求/相应模式而构建的。长期以来存在这个各种技术让服务器得知有数据可用时，立即将数据发送到客户端。最常用的一种技术手段是对服务器发起链接创建假象，被称为长轮循。利用长轮循，客户端可以打开指向服务器的Http连接，而服务器会一直保持链接打开，直到发送响应。服务器只要有数据，就会发送响应。这些问题都存在一个同样的问题，Http协议的开销，到时他们不适用于低延迟应用。</p>
<p>  为了解决这些问题，WebSocket将网络套接字引入到了客户端和服务器端，浏览器和服务器之间可以通过套接字建立持久的连接，双方随时都可以互发数据给对方，而不是由客户端控制的一对一应答模式。</p>
<h3 id="Http协议弊端"><a href="#Http协议弊端" class="headerlink" title="Http协议弊端"></a>Http协议弊端</h3><p>  Http主要弊端总结</p>
<ul>
<li>半双工模式。不能同时传送数据，意味着一个时刻，只有一个方向上的数据传送</li>
<li>Http消息冗长复杂。Http消息包括消息头、消息体、换行符等，通常情况下采用文本传输，，相比于其他的二进制通讯，冗长而复杂</li>
<li>针对服务器推送的黑客攻击，例如长轮询</li>
</ul>
<p>  比较新的一种轮询技术是Comet，使用了Ajax。这种技术虽然可达到双工通信，但依然需要发送请求，而且在Comet中，普遍采用了长连接，这也会大量消耗服务器款到和资源。</p>
<p>  为了解决Http协议效率底下的问题，HTML5定义了WebSocket协议，能更好的节省服务器资源和宽带并达到定时通信。</p>
<h3 id="WebSocket入门"><a href="#WebSocket入门" class="headerlink" title="WebSocket入门"></a>WebSocket入门</h3><p>  WebSocket主要特点</p>
<ul>
<li>单一的TCP连接，采用了全双工模式通信</li>
<li>对代理、防火墙和路由器透明</li>
<li>无头部信息、Cookies和身份验证</li>
<li>无安全开销</li>
<li>通过Ping/Pong帧保持链路激活</li>
<li>服务器可以主动传递消息给客户端，不再需要客户端轮询</li>
</ul>
<p>  WebSocket的目的是为了取代轮询和Coment技术，使客户端浏览器具备像C/S架构下桌面系统一样的实时通信能力。</p>
<ol>
<li>建立连接<br> <strong>客户端—&gt;握手请求—&gt;服务器—&gt;握手相应</strong></li>
<li>生命周期<br>   握手成功之后，客户端和服务器端就可以通过”messages”的方式进行通信了，一个消息由一个或多个帧组成，WebSocket的消息并不一定对应某一个特定网络层的帧，它可以被分割成多个或被合并。</li>
<li>关闭连接<br>   为关闭WebSocket连接，客户端和服务端需要通过一个安全的方法关闭底层TCP连接以及TLS会话。如果合适，丢弃任何核能已经接受的字节。<br>   WebSocket的握手关闭消息带有一个状态码和一个可选的关闭原因，它必须按照协议要求发送一个关闭控制流，当对接接收到关闭控制帧时，需要主动关闭WebSocket连接。</li>
</ol>
<h3 id="Netty-WebSocket开发"><a href="#Netty-WebSocket开发" class="headerlink" title="Netty WebSocket开发"></a>Netty WebSocket开发</h3><p>  Netty基于Http协议开发了WebSocket协议栈，利用Netty的WebSocket协议栈可非常方便的开发出WebSocket客户端和服务器端。</p>
<p>基于Netty的WebSocket编程主要代码<br></p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInBoundHandler</span>&lt;<span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInBoundHandler</span>&lt;<span class="hljs-title">Object</span>&gt;</span>{

    <span class="hljs-keyword">private</span> WebSocketServerHandshaker handshaker;

    <span class="hljs-comment">// define Logger</span>
    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageReceived</span><span class="hljs-params">(ChannelHandlerContext ctx,Object msg)</span></span>{

        <span class="hljs-comment">// 传统的Http接口</span>
        <span class="hljs-keyword">if</span>(msg <span class="hljs-keyword">instanceof</span> FullHttpRequest){
            handleHttpRequest(ctx,(FullHttpRequest)msg);
        }
        <span class="hljs-comment">// WebSocket接入</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(msg <span class="hljs-keyword">instanceof</span> WebSocketFrame){
            handleWebSocketFrame(ctx,(WebSocketFrame)msg);
        }
    }

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>{
        ftx.flush();
    }

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable e)</span> <span class="hljs-keyword">throws</span> Exception</span>{
        cause.printStackTrace();
        ctx.close();
    }

    <span class="hljs-comment">// define local method</span>
    <span class="hljs-comment">// handle websocket http request</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleHttpRequst</span><span class="hljs-params">(ChannelHandlerContext ctx,FullHttpRequest req)</span> <span class="hljs-keyword">throws</span> Exception</span>{

        <span class="hljs-comment">// 如果Http编码失败，返回Http异常</span>
        <span class="hljs-keyword">if</span>(!req.getDecoderResult().isSuccesss() || (!<span class="hljs-string">"websocket"</span>.equals(req.headers().get(<span class="hljs-string">"Upgrade"</span>)))){
            sendHttpResponse(ctx,req,<span class="hljs-keyword">new</span> DefaultFullHttpResponse(HTTP_1_1,BAD_REQUEST));
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// 构造握手相应返回，本机测试</span>
        WebSocketServerHandShakerFactory wsFactory = <span class="hljs-keyword">new</span> WebSocketServerHandShakerFactory(<span class="hljs-string">"ws://localhost:8080/websocket"</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>);
        handshaker = wsFactory.newHandshaker(req);
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span>==handshaker){
            WebSocketServerHandShakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());
        }<span class="hljs-keyword">else</span>{
            handshaker.handshake(ctx.channel(),req);
        }

    }

    <span class="hljs-comment">// handler websocket request</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleWebSocketRequest</span><span class="hljs-params">(ChannelHandlerContext ctx,WebSocketFrame req)</span> <span class="hljs-keyword">throws</span> Exception</span>{

        <span class="hljs-comment">// 判断是否关闭链路指令</span>
        <span class="hljs-keyword">if</span>(frame <span class="hljs-keyword">instanceof</span> CloseWebSocketFrame){
            handshaker.close(ctx.channel(),(CloseWebSocketFrame)farme.retain());
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// 判断是否Ping消息</span>
        <span class="hljs-keyword">if</span>(frame <span class="hljs-keyword">instanceof</span> PingWebSocketFrame){
            ctx.channel().write(<span class="hljs-keyword">new</span> PongWebSocketFrame(frame.contenet().retain()));
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// 本利仅支持文本消息，比支持二进制消息</span>
    <span class="hljs-keyword">if</span>(!(frame <span class="hljs-keyword">instanceof</span> TextWebSocketFrame)){
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(String.format(<span class="hljs-string">"$s frame types not supported"</span>,frame.getClass().getName()));
    }

    <span class="hljs-comment">//返回应答消息</span>
    String request = ((TextWebSocketFrame)frame).text();
    ctx.channel().write(<span class="hljs-keyword">new</span> TextWebSocketFrame(request+<span class="hljs-string">", 欢迎使用Netty WebSocket服务，现在时间："</span>+<span class="hljs-keyword">new</span> java.util.Date().toString());
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendHttpResponse</span><span class="hljs-params">(ChannelHandlerContext ctx,FullHttpRequest req,FullHttpResponse res)</span></span>{

        <span class="hljs-comment">// 返回应答给客户端</span>
        <span class="hljs-keyword">if</span>(req.getStatus().code()!=<span class="hljs-number">200</span>){
            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(),CharsetUtil.UTF_8);
            res.content().writeBytes(buf);
            buf.release();
            setContentLength(res,res.content().readableBytes());
        }

        <span class="hljs-comment">// 如果是非Kill-Alive，关闭连接</span>
        ChannelFuture f = ctx.channel().writeAndFlush(res);
        <span class="hljs-keyword">if</span>(!isKeepAlive(req) || res.getStatus.code()!=<span class="hljs-number">200</span>){
            f.addListener(ChannelFutureListener.CLOSE);
        }
    }
}</code></span></span></pre><p></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>  本章主要介绍了Http协议的弊端和WebSocket的一些技术背景，随后对WebSocket的优势和基础入门进行了介绍，包括WebSocket的握手请求和相应、连接的建立与关闭、WebSocket的生命周期等内容。</p>
<h2 id="UDP协议开发"><a href="#UDP协议开发" class="headerlink" title="UDP协议开发"></a>UDP协议开发</h2><p>  UDP是用户数据报协议(User Datagram Protocol, UDP)的简称，其主要作用是将网络数据流量压缩成数据报形式，提供面向事物的简单消息传送服务。与TCP相比，UDP协议直接利用IP协议进行UDP数据报的传输，UDP面向的是无连接、不可靠的数据投递服务。当使用UDP时，用户应用必须负责解决数据报丢失、重复、排序、差错确认等问题。</p>
<p>  由于UDP具有资源消耗小、处理速度快的优点，所以通常视频、音频等可靠性要求不高的数据传输一般会使用UDP，即便有一定的丢包率，也不会对功能造成严重的影响。</p>
<h3 id="UDP协议简介"><a href="#UDP协议简介" class="headerlink" title="UDP协议简介"></a>UDP协议简介</h3><p>  UDP数据分为首部和数据两个部分。首部简单，为8个字节，包括</p>
<ul>
<li>源端口：源端口号，2个字节，最大值为65535</li>
<li>目的端口：目的端口号，2个字节，最大为65535</li>
<li>长度：2个字节，UDP用户数据报的总长度</li>
<li>校验和：2字节，用于校验UDP数据报的数字段和包含UDP数据报首部的“伪首部”。</li>
</ul>
<p>  UDP协议的特点</p>
<ul>
<li>UDP传送数据前并不与对方建立连接，即UDP是无连接的。在数据发送前，发送方和接收方相互交换信息是双方同步</li>
<li>UDP对接受到的数据报不发送确认信号，发送端不知道数据是否被正确接受，也不会重发数据</li>
<li>UDP发送数据比TCP快，系统开销少：UDP简单、灵活。</li>
</ul>
<h3 id="UDP服务端开发"><a href="#UDP服务端开发" class="headerlink" title="UDP服务端开发"></a>UDP服务端开发</h3><p><img src="./Netty权威指南读书笔记/002.png" srcset="/img/loading.gif" alt="UDP开发流程"></p>
<h3 id="UDP客户端开发"><a href="#UDP客户端开发" class="headerlink" title="UDP客户端开发"></a>UDP客户端开发</h3><p>  总体而言UDP开发相对简单，客户端开发可参考服务器端开发代码。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>  由于UDP相比于TCP的应用领域窄一些，所以本章不做详细论述。</p>
<h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><p>  文件是最常见的数据源之一，在程序中经常需要将数据存储到文件中。在NIO的类库之前，Java所有的文件操作分为两类</p>
<ul>
<li>基于字节流的InputStream和OutputStream</li>
<li>基于字符流的Reader和Writer</li>
</ul>
<p>  通过NIO提供的Channel类库，可以方便的以“管道”方式对文件进行各种IO操作，相比于传统的IO操作有了较高改进。</p>
<h3 id="文件的基础知识"><a href="#文件的基础知识" class="headerlink" title="文件的基础知识"></a>文件的基础知识</h3><p>  文件是计算机中一种基本的数据存储形式，在时间存储数据时，如果对数据进行的读写速度要求不是很高，存储数量也不是很大，使用文件作为一种持久化的方式是比较好的选择。文件需要注意几个概念</p>
<ul>
<li>文件路径</li>
<li>文件名称</li>
</ul>
<h3 id="Netty文件传输开发"><a href="#Netty文件传输开发" class="headerlink" title="Netty文件传输开发"></a>Netty文件传输开发</h3><p>  文件传输通常使用FTP或Http附件的方式。事实上通过TCP Socket+File的方式进行文件传输也有一定的应用场景，尽管不是主流，但掌握这种文件阐释方式还是非常重要的，特别是针对跨主机的JVM进城之间进行持久化数据的相互交换。</p>
<p>  示例Netty程序的应用场景</p>
<ol>
<li>Netty文件服务器启动，绑定8000作为内部监听端口</li>
<li>在CMD控制台上，通过telnet和文件服务器建立tcp连接</li>
<li>在控制台输入需要下载的文件绝对路径</li>
<li>文件服务器接受到请求消息后进行合法性判断，如果文件存在，则将文件发送给CDM控制台</li>
<li>CMD控制台打印文件名和文件内存</li>
</ol>
<p>  主要处理类<br></p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSererHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInBoundHandler</span>&lt;<span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSererHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInBoundHandler</span>&lt;<span class="hljs-title">String</span>&gt;</span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CR = System.getProperty(<span class="hljs-string">"line.separator"</span>);

    <span class="hljs-meta">@override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageReceived</span><span class="hljs-params">(ChannelHandlerContext ctx,String msg)</span></span>{
        File f = <span class="hljs-keyword">new</span> File(msg);
        <span class="hljs-keyword">if</span>(!f.exists()){
            ctx.writeAndFlush(<span class="hljs-string">"Not a file :"</span>+f+CR);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span>(!f.isFile()){
            ctx.writeAndFlush(<span class="hljs-string">"File not found :"</span>+f+CR);
            <span class="hljs-keyword">return</span>;
        }

        ctx.write(f+<span class="hljs-string">" "</span>+f.length()+CR);
        RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(msg,<span class="hljs-string">'r'</span>);
        FileRegion fr = <span class="hljs-keyword">new</span> DefaultFileRegion(raf,getChannel(),<span class="hljs-number">0</span>,raf.length());
        ctx.write(region);
        ctx.writeAndFlush(CR);
        raf.close();
    }
}</code></span></span></pre><p></p>
<h2 id="私有协议栈开发"><a href="#私有协议栈开发" class="headerlink" title="私有协议栈开发"></a>私有协议栈开发</h2><p>  通信协议从广义上区分，可以分为共有协议和私有协议。由于私有协议的灵活性，它往往会在某个公司或组织内部使用，按需定制。绝大数私有协议传输层都是基于TCP/IP，所以利用Netty的NIO TCP协议栈可以非常方便的进行私有协议的定制和开发。</p>
<h3 id="私有协议介绍"><a href="#私有协议介绍" class="headerlink" title="私有协议介绍"></a>私有协议介绍</h3><p>  传统中的Java应用中，通常使用以下四种方式进行跨界点调用</p>
<ul>
<li>通过RMI进行远程服务调用</li>
<li>通过java的socket+java序列化的方式进行扩节点调用</li>
<li>利用一些开源的RPC，例如Thrift,Avro</li>
<li>利用标准的共有协议进行调用，例如Http+XML、RestFull+JSON</li>
</ul>
<h3 id="Netty协议栈功能设计"><a href="#Netty协议栈功能设计" class="headerlink" title="Netty协议栈功能设计"></a>Netty协议栈功能设计</h3><h4 id="协议栈拓扑图"><a href="#协议栈拓扑图" class="headerlink" title="协议栈拓扑图"></a>协议栈拓扑图</h4><h4 id="协议栈功能描述"><a href="#协议栈功能描述" class="headerlink" title="协议栈功能描述"></a>协议栈功能描述</h4><h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><h4 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h4><h4 id="Netty协议栈支持的字段类型"><a href="#Netty协议栈支持的字段类型" class="headerlink" title="Netty协议栈支持的字段类型"></a>Netty协议栈支持的字段类型</h4><h4 id="Netty协议栈的编码规范"><a href="#Netty协议栈的编码规范" class="headerlink" title="Netty协议栈的编码规范"></a>Netty协议栈的编码规范</h4><h4 id="链路的建立"><a href="#链路的建立" class="headerlink" title="链路的建立"></a>链路的建立</h4><h4 id="链路的关闭"><a href="#链路的关闭" class="headerlink" title="链路的关闭"></a>链路的关闭</h4><h4 id="可靠性设计"><a href="#可靠性设计" class="headerlink" title="可靠性设计"></a>可靠性设计</h4><ol>
<li>心跳机制</li>
<li>重连集资</li>
<li>重复登录保护</li>
<li>消息缓冲重发</li>
</ol>
<h4 id="安全性设计"><a href="#安全性设计" class="headerlink" title="安全性设计"></a>安全性设计</h4><p>  安全策略</p>
<ul>
<li>IP+白名单</li>
<li>ASE加密的用户名+密码认证机制</li>
</ul>
<h4 id="可靠性设计-1"><a href="#可靠性设计-1" class="headerlink" title="可靠性设计"></a>可靠性设计</h4><h3 id="Netty协议栈开发"><a href="#Netty协议栈开发" class="headerlink" title="Netty协议栈开发"></a>Netty协议栈开发</h3><h1 id="源码分析篇-Netty功能介绍和源码分析"><a href="#源码分析篇-Netty功能介绍和源码分析" class="headerlink" title="源码分析篇 Netty功能介绍和源码分析"></a>源码分析篇 Netty功能介绍和源码分析</h1><h2 id="ByteBuf和相关辅助类"><a href="#ByteBuf和相关辅助类" class="headerlink" title="ByteBuf和相关辅助类"></a>ByteBuf和相关辅助类</h2><p>  </p>
<h2 id="Channel和Unsafe"><a href="#Channel和Unsafe" class="headerlink" title="Channel和Unsafe"></a>Channel和Unsafe</h2><p>  </p>
<h2 id="ChannelPipeline和ChannelHandler"><a href="#ChannelPipeline和ChannelHandler" class="headerlink" title="ChannelPipeline和ChannelHandler"></a>ChannelPipeline和ChannelHandler</h2><p>  </p>
<h2 id="EventLoop和EventLoopGroup"><a href="#EventLoop和EventLoopGroup" class="headerlink" title="EventLoop和EventLoopGroup"></a>EventLoop和EventLoopGroup</h2><p>  </p>
<h2 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h2><p>  </p>
<h1 id="架构和行业应用篇-Netty高级特性"><a href="#架构和行业应用篇-Netty高级特性" class="headerlink" title="架构和行业应用篇 Netty高级特性"></a>架构和行业应用篇 Netty高级特性</h1><p>  </p>
<h2 id="Java多线程编程在Netty中的应用"><a href="#Java多线程编程在Netty中的应用" class="headerlink" title="Java多线程编程在Netty中的应用"></a>Java多线程编程在Netty中的应用</h2><p>  作为异步事件驱动、高性能的NIO框架，Netty代码中大量运用了Java多线程编程技巧，并发编程处理的恰当与否，将直接影响到架构的性能。</p>
<h3 id="Java内存模型与多线程编程"><a href="#Java内存模型与多线程编程" class="headerlink" title="Java内存模型与多线程编程"></a>Java内存模型与多线程编程</h3><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>  JVM定义了内存规范，规避了各种操作系统、虚拟机实现和硬件的内存访问差异，以确保Java程序在所有操作系统上和平台上能够实现一次编写、到处运行的效果。</p>
<p>  Java内存模型的制定既要严谨，保证语义无歧义，还要尽量制定的宽松一些，运行硬件和虚拟机厂商有足够的灵活性来充分利用硬件的特性提升Java内存访问性能。</p>
<ol>
<li>工作内存和主内存</li>
<li>Java内存交互协议<ul>
<li>lock</li>
<li>unlock</li>
<li>read</li>
<li>write</li>
<li>load</li>
<li>store</li>
<li>assign</li>
<li>use</li>
</ul>
</li>
<li>java的线程 <ul>
<li>内核线程</li>
<li>用户线程</li>
<li>混合实现</li>
</ul>
</li>
</ol>
<h3 id="Netty的并发编程实践"><a href="#Netty的并发编程实践" class="headerlink" title="Netty的并发编程实践"></a>Netty的并发编程实践</h3><h4 id="对共享的可变数据进行正确的同步"><a href="#对共享的可变数据进行正确的同步" class="headerlink" title="对共享的可变数据进行正确的同步"></a>对共享的可变数据进行正确的同步</h4><h4 id="正确使用锁"><a href="#正确使用锁" class="headerlink" title="正确使用锁"></a>正确使用锁</h4><h4 id="volatile的正确使用"><a href="#volatile的正确使用" class="headerlink" title="volatile的正确使用"></a>volatile的正确使用</h4><p>  volatile修饰之后，具有两种特性</p>
<ul>
<li>线程可见性</li>
<li>禁止指令重排</li>
</ul>
<h4 id="CAS指令和元子类"><a href="#CAS指令和元子类" class="headerlink" title="CAS指令和元子类"></a>CAS指令和元子类</h4><p>  互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能的额外损耗，因此这种同步被称为阻塞同步，它是一种悲观的并发策略，称为悲观锁。随着硬件和操作系统指令集的发展和优化，产生了非阻塞同步，被称为乐观锁。</p>
<p>  目前Java中的非阻塞同步就是CAS，基本上是通过系统操作指令来完成。</p>
<h4 id="线程安全类的使用"><a href="#线程安全类的使用" class="headerlink" title="线程安全类的使用"></a>线程安全类的使用</h4><p>  在JDK1.5之后，Java平台新增了java.util.concurrent这个包，提供了一些列线程安全集合、容器和线程池，利用这些新的线程安全类极大地降低了Java多线程编程的难度，提升了开发效率。新的并发编程包中的工具可以分为</p>
<ul>
<li>线程池Executor Framework以及定时任务相关的类库，包括Timer等</li>
<li>并发集合，包括List、Queue、Map和Set等</li>
<li>新的同步器，例如读写锁ReadWriteLock等</li>
<li>新的原子包装类，例如AtomicInteger等</li>
</ul>
<h2 id="Netty架构剖析"><a href="#Netty架构剖析" class="headerlink" title="Netty架构剖析"></a>Netty架构剖析</h2><h3 id="Netty逻辑架构"><a href="#Netty逻辑架构" class="headerlink" title="Netty逻辑架构"></a>Netty逻辑架构</h3><ol>
<li>reactor通信调度层</li>
<li>职责链channelpipeline</li>
<li>业务逻辑编排层</li>
</ol>
<h3 id="关键架构质量属性"><a href="#关键架构质量属性" class="headerlink" title="关键架构质量属性"></a>关键架构质量属性</h3><ol>
<li>高性能</li>
<li>可靠性<ul>
<li>链路有效性检测</li>
<li>内存保护机制</li>
<li>优雅停机</li>
<li>可定制型</li>
<li>可扩展性</li>
</ul>
</li>
</ol>
<h2 id="Netty行业应用"><a href="#Netty行业应用" class="headerlink" title="Netty行业应用"></a>Netty行业应用</h2><ol>
<li>Dubbo</li>
<li>大数据领域</li>
<li>游戏领域</li>
</ol>
<h2 id="Netty未来展望"><a href="#Netty未来展望" class="headerlink" title="Netty未来展望"></a>Netty未来展望</h2>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/Netty/">Netty</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2018/07/10/%E5%88%86%E5%B8%83%E5%BC%8FJava%E5%BA%94%E7%94%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分布式Java应用读书笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2018/07/07/%E4%BA%94%E7%A7%8D%E5%8A%A0%E5%BF%ABHive%E8%BF%90%E8%A1%8C%E7%9A%84%E6%96%B9%E5%BC%8F/">
                        <span class="hidden-mobile">五种加快Hive查询的方式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>



<!-- Plugins -->


  
    
  



  <script defer="" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  



  
  



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  

  






















<script src="/bundle.js"></script><script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  ;

    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Netty权威指南读书笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  ;

    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  ;

    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  ;

    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script></body></html>